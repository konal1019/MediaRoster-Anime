const CACHE_DURATION=3e5,BASE_URL="https://api.jikan.moe/v4";export const genres={};const logErrorByStatus=(e,t)=>{switch(e){case 400:console.log("You've made an invalid request. Recheck documentation");break;case 404:console.log("The resource was not found or MyAnimeList responded with a 404");break;case 405:console.log("Requested Method is not supported for resource. Only GET requests are allowed");break;case 429:console.log("You are being rate limited by Jikan or MyAnimeList is rate-limiting our servers");break;case 500:console.log("Something didn't work. Try again later. If you see an error response with a report_url URL, please click on it to open an auto-generated GitHub issue");break;case 503:console.log("Jikan service is down. Try again later");break;default:console.log("Unknown Error while fetching data"),console.log(`${e} : ${t}`)}},fetchWithCache=async(e,t)=>{const a=Date.now(),o=localStorage.getItem(t);if(o)try{const{data:e,timestamp:r}=JSON.parse(o);if(a-r<3e5)return console.log(`Cache hit for key: ${t}`),e}catch(e){console.error(`Error parsing cached data for key ${t}:`,e),localStorage.removeItem(t)}for(let o=0;o<5;o++)try{console.log(`Fetching data for URL: ${e}`);const r=await fetch(e,{method:"GET"});if(200===r.status||304===r.status){const e=(await r.json()).data;try{localStorage.setItem(t,JSON.stringify({data:e,timestamp:a}))}catch(o){if("QuotaExceededError"===o.name){console.warn("LocalStorage quota exceeded. Clearing oldest cache entries.");const o=Object.keys(localStorage).map(e=>{try{const t=JSON.parse(localStorage.getItem(e));if(t&&t.timestamp)return{key:e,timestamp:t.timestamp}}catch(e){}return null}).filter(e=>null!==e);o.sort((e,t)=>e.timestamp-t.timestamp);const r=Math.min(5,o.length);for(let e=0;e<r;e++)console.log(`Removing old cache: ${o[e].key}`),localStorage.removeItem(o[e].key);try{localStorage.setItem(t,JSON.stringify({data:e,timestamp:a}))}catch(e){console.error("Failed to cache data even after clearing some entries:",e)}}else console.error("Error saving to localStorage:",o)}return e}logErrorByStatus(r.status,r.statusText),console.warn(`API request failed with status ${r.status}. Retrying...`),await new Promise(e=>setTimeout(e,1e3*(o+1)))}catch(t){if(console.error(`Error fetching data from ${e}:`,t),4===o)throw t;await new Promise(e=>setTimeout(e,1e3*(o+1)))}throw new Error(`Failed to fetch data from ${e} after 5 retries.`)},fetchWithoutCache=async e=>{for(let t=0;t<5;t++)try{console.log(`Fetching data for URL: ${e}`);const a=await fetch(e,{method:"GET"});if(200===a.status||304===a.status)return await a.json();logErrorByStatus(a.status,a.statusText),console.warn(`API request failed with status ${a.status}. Retrying...`),await new Promise(e=>setTimeout(e,1e3*(t+1)))}catch(a){if(console.error(`Error fetching data from ${e}:`,a),4===t)throw a;await new Promise(e=>setTimeout(e,1e3*(t+1)))}throw new Error(`Failed to fetch data from ${e} after 5 retries.`)};export const getTopRatedAnime=async()=>{const e=`${BASE_URL}/top/anime`;return await fetchWithCache(e,"top_rated_anime")};export const getMostPopularAnime=async()=>{const e=`${BASE_URL}/top/anime?filter=bypopularity`;return await fetchWithCache(e,"most_popular_anime")};export const getAiringAnime=async()=>{const e=`${BASE_URL}/anime?status=airing`;return await fetchWithCache(e,"airing_anime")};export const getUpcomingAnime=async()=>{const e=`${BASE_URL}/seasons/upcoming`;return await fetchWithCache(e,"upcoming_anime")};export const getSeasonalAnime=async()=>{const e=`${BASE_URL}/seasons/now`;return await fetchWithCache(e,"seasonal_anime")};export const getGenres=async()=>{const e=`${BASE_URL}/genres/anime`;(await fetchWithCache(e,"anime_genres")).forEach(e=>{genres[e.mal_id]=e.name}),console.log("loaded genres")};export const getAnimeDetails=async e=>{const t=`${BASE_URL}/anime/${e}/full`,a=`anime_details_${e}`;return await fetchWithCache(t,a)};export const getAnimeInfo=async e=>{const t=`${BASE_URL}/anime/${e}`;return await fetchWithoutCache(t)};export const getAnimeCharacters=async e=>{const t=`${BASE_URL}/anime/${e}/characters`;return await fetchWithoutCache(t)};export const getAnimeStaff=async e=>{const t=`${BASE_URL}/anime/${e}/staff`;return await fetchWithoutCache(t)};export const getRandomAnime=async()=>(await fetchWithoutCache(`${BASE_URL}/random/anime`)).data;export const getAnimeReviews=async e=>{const t=`${BASE_URL}/anime/${e}/reviews`;return(await fetchWithoutCache(t)).data};export async function searchAnime(e){return e?await fetchWithoutCache(e):fetchWithCache(`${BASE_URL}/anime`)}